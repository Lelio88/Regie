<!doctype html>
triggerReplay();
}
requestAnimationFrame(loop);
}
loop();
}


function triggerReplay() {
const blob = getBufferedBlob();
if (!blob || blob.size === 0) { console.warn('no buffer'); return; }
const url = URL.createObjectURL(blob);
const v = document.createElement('video');
v.src = url;
v.controls = false;
v.autoplay = true;
v.style.position = 'fixed';
v.style.right = '10px';
v.style.bottom = '10px';
v.style.width = '40%';
v.style.zIndex = 9999;
document.body.appendChild(v);
// remove after playing
v.onended = () => { document.body.removeChild(v); URL.revokeObjectURL(url); };
}


// When a phone joins, create an RTCPeerConnection and wait for offer
socket.on('phone-joined', ({ phoneId }) => {
console.log('phone joined', phoneId);
});


// This server proxies offers from phones to dashboard; we receive an 'offer' event
socket.on('offer', async ({ from, sdp }) => {
console.log('offer from', from);
const pc = new RTCPeerConnection();
pcs[from] = pc;


pc.ontrack = (ev) => {
console.log('ontrack', from, ev.streams);
const stream = ev.streams[0];
remoteStreams[from] = stream;
attachMiniStream(from, stream);
// If this becomes main video, set srcObject
};


pc.onicecandidate = (e) => {
if (e.candidate) {
socket.emit('ice-candidate', { targetId: from, candidate: e.candidate });
}
};


await pc.setRemoteDescription(new RTCSessionDescription(sdp));
const answer = await pc.createAnswer();
await pc.setLocalDescription(answer);
socket.emit('answer', { targetId: from, sdp: pc.localDescription });


// Listen for ICE candidates from server
socket.on('ice-candidate', async ({ from: sender, candidate }) => {
if (sender === from) {
try { await pc.addIceCandidate(candidate); } catch(e){ console.warn(e); }
}
});
});


socket.on('phone-left', ({ phoneId }) => {
console.log('phone left', phoneId);
// remove UI
const el = document.getElementById(